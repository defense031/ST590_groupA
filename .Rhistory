load("~/tmp/ST590_groupA/.RData")
knitr::opts_chunk$set(echo = TRUE)
library(jsonlite)
library(dplyr)
library(tidyr)
digital <- fromJSON("https://www4.stat.ncsu.edu/~post/558/datasets/russian_ads.json", flatten = TRUE)
str(digital)
View(digital)
# Convert to tibble
digital_tb <- as_data_frame(digital)
# As an example
digital_tb %>% dplyr::mutate(location_categories = as.character(location_categories)) %>% dplyr::select(location_categories)
# As an example
example<-digital_tb %>% dplyr::mutate(location_categories = as.character(location_categories)) %>% dplyr::select(location_categories)
View(example)
# unnest the first 2 columns
digital_tb_unnest <- digital_tb %>% unnest(language_categories, .drop = FALSE) %>% unnest(placement_categories, .drop = FALSE)
digital_tb_unnest$language_categories
View(digital_tb_unnest)
#first attempt at some aggregation
g<-ggplot(digital_tb_unnest, aes(x=ad_spend_usd, y=conversion_rate))
#first attempt at some aggregation
library(ggplot2)
g<-ggplot(digital_tb_unnest, aes(x=ad_spend_usd, y=conversion_rate))
g+geom_point()
digital_dropna<-digital_tb_unnest %>% drop_na(ad_spend_usd)
g<-ggplot(digital_dropna, aes(x=ad_spend_usd, y=conversion_rate))
g+geom_point()
View(digital_dropna)
digital_dropna<-digital_tb_unnest %>% drop_na(ad_spend_usd) %>% drop_na(ad_impressions)
g<-ggplot(digital_dropna, aes(x=ad_spend_usd, y=conversion_rate))
g+geom_point()
g2+geom_bar()
g2<-ggplot(digital_dropna,aes(aes(x=placements)))
g2+geom_bar()
g2<-ggplot(digital_dropna,aes(aes(x=interests_categories_regex)))
g2+geom_bar()
g2<-ggplot(digital_dropna,aes(x=placements))
g2+geom_bar()
g3<-ggplot(digital_dropna, aes(x=as.factor(year), y=ad_spend_usd))
g3+geom_boxplot()
g3<-ggplot(digital_dropna, aes(x=as.factor(year), y=conversion_rate))
g3<-ggplot(digital_dropna, aes(x=as.factor(year), y=conversion_rate))
g3+geom_boxplot()
g3<-ggplot(digital_dropna, aes(x=as.factor(year), y=efficiency_impressions))
g3+geom_boxplot()
knitr::opts_chunk$set(echo = TRUE)
library(jsonlite)
library(dplyr)
library(tidyr)
digital <- fromJSON("https://www4.stat.ncsu.edu/~post/558/datasets/russian_ads.json", flatten = TRUE)
str(digital)
# As you look closer you would notice the first 4 columns (variables) are ‘list’ data type and they are ‘nested’. This is because each ‘categories’ columns include an JS array data object in the original JSON data.
# For Example (Look at the middle bracket[])
# "language_categories": [
#       "Not Specified"
#     ],
#     "placement_categories": [
#       "Facebook"
#     ],
#     "interests_categories": [],
#     "location_categories": [
#       "Midwest",
#       "Atlantic"
#     ]
# So even after the flattening the data, this type of variables are registered as ‘list’ data type and it has a list of the values (or atomic vector) for each row of the data frame. You can easily show the values inside of this type of variable by using as.character() function like below.
# Convert to tibble
digital_tb <- as_data_frame(digital)
# As an example
digital_tb %>% dplyr::mutate(location_categories = as.character(location_categories)) %>% dplyr::select(location_categories)
# To break out ‘categories’ list columns and create one row for each value, we can use ‘unnest()’ function from tidyr package.
# unnest 4 columns using stepwise approach. .drop = FALSE keeps other lsit columns that have not been unnested yet in the process.
digital_tb_unnest_noempty <- digital_tb %>% unnest(language_categories, .drop = FALSE) %>% unnest(placement_categories, .drop = FALSE) %>% unnest(interests_categories, .drop = FALSE) %>% unnest(location_categories, .drop = FALSE)
# Unnested columns are at the end of the dataset
dim(digital_tb_unnest_noempty)
# Checking dimension, there are 1803 observations, which is less than 3517 from the original parsed dataset. This is due to 3rd and 4th columns containing character(0), i.e. character array with 0 length, these 2 columns can't be unnested by default unnest(). Otherwise, it drop all the rows with 1 or more empty data points in those list columns.
# We can use the _regex version of interests_categories and locations_categories, then use detect string functions for aggregation
# Or try to unnest the rows without empty points and join back to the master dataset. This seems to be a more holistic solution.
# Check if ad_id is unique
sum(table(digital_tb$ad_id)!=1)
# returns 0. ad_id can theoretically serve as a join key
# Wait!
sum(is.na(digital_tb$ad_id))
# unfortunately, there are 151 NAs in ad_id. Let's create our own row_id.
digital_tb <- digital_tb %>% mutate(own_id = rownames(digital_tb)) %>% select(own_id, everything())
# Grab language_categories list column and own_id, unnest it, assign it to table_inter1.
# unnest() by default will remove empty points character(0), but explicitly filtering first would result in faster execution. It probably does not matter in this case.
# Also, be aware that lengths() is different from length(). lengths() checks the length of each element of the list column
table_inter1 <- digital_tb %>% select(language_categories, own_id) %>% filter(lengths(language_categories) > 0) %>% unnest()
# If the unnest works properly, there should be a row for each value in the vectors.
# Check if the number of rows of table_inter1 is equal to the sum of array elements.
sum(lengths(digital_tb$language_categories)) == dim(table_inter1)[1]
# TRUE. We are good. Apply the same method to the other 3 columns.
table_inter2 <- digital_tb %>% select(placement_categories, own_id) %>% filter(lengths(placement_categories) > 0) %>% unnest()
table_inter3 <- digital_tb %>% select(interests_categories, own_id) %>% filter(lengths(interests_categories) > 0) %>% unnest()
table_inter4 <- digital_tb %>% select(location_categories, own_id) %>% filter(lengths(location_categories) > 0) %>% unnest()
# Left table is master. Right table is the table of unnested column and own_id.
digital_fully_unnest <- digital_tb %>% left_join(table_inter1, by = "own_id") %>% left_join(table_inter2, by = "own_id") %>% left_join(table_inter3, by = "own_id") %>% left_join(table_inter4, by = "own_id")
# It works. The resulting tibble is fully unnested. Rows are duplicated properly for each unique combination of category values.
# Remove the list columns (.x suffix) from the original left table and put freshly joined columns (.y suffix) at front.
df <- digital_fully_unnest %>% select(-ends_with('.x'), -own_id) %>% select(ends_with('.y'), everything())
colnames(df) = gsub(".y", "", colnames(df))
# Use df for further analysis
View(df)
View(df)
# For example
e<-df %>% filter(ad_id == 1147) %>% select(ends_with("categories"), ad_spend_usd)
e
View(e)
View(df)
knitr::opts_chunk$set(echo = TRUE)
```{r Read}
library(jsonlite)
library(dplyr)
library(tidyr)
digital <- fromJSON("https://www4.stat.ncsu.edu/~post/558/datasets/russian_ads.json", flatten = TRUE)
# Convert to tibble
digital_tb <- as_data_frame(digital)
# unnest 4 columns using stepwise approach. .drop = FALSE keeps other list columns that have not been unnested yet in the process.
digital_tb_unnest_noempty <- digital_tb %>% unnest(language_categories, .drop = FALSE) %>% unnest(placement_categories, .drop = FALSE) %>% unnest(interests_categories, .drop = FALSE) %>% unnest(location_categories, .drop = FALSE)
digital_tb <- digital_tb %>% mutate(own_id = rownames(digital_tb)) %>% select(own_id, everything())
View(digital_tb)
# unnest 4 columns using stepwise approach. .drop = FALSE keeps other list columns that have not been unnested yet in the process.
digital_tb_unnest_noempty <- digital_tb %>% unnest(language_categories, .drop = FALSE) %>% unnest(placement_categories, .drop = FALSE) %>% unnest(interests_categories, .drop = FALSE) %>% unnest(location_categories, .drop = FALSE)
View(digital_tb_unnest_noempty)
# TRUE. We are good. Apply the same method to the other 3 columns.
table_inter2 <- digital_tb %>% select(placement_categories, own_id) %>% filter(lengths(placement_categories) > 0) %>% unnest()
table_inter3 <- digital_tb %>% select(interests_categories, own_id) %>% filter(lengths(interests_categories) > 0) %>% unnest()
table_inter4 <- digital_tb %>% select(location_categories, own_id) %>% filter(lengths(location_categories) > 0) %>% unnest()
View(table_inter2)
View(table_inter3)
# Left table is master. Right table is the table of unnested column and own_id.
digital_fully_unnest <- digital_tb %>% left_join(table_inter1, by = "own_id") %>% left_join(table_inter2, by = "own_id") %>% left_join(table_inter3, by = "own_id") %>% left_join(table_inter4, by = "own_id")
# Grab language_categories list column and own_id, unnest it, assign it to table_inter1.
# unnest() by default will remove empty points character(0), but explicitly filtering first would result in faster execution. It probably does not matter in this case.
# Also, be aware that lengths() is different from length(). lengths() checks the length of each element of the list column
table_inter1 <- digital_tb %>% select(language_categories, own_id) %>% filter(lengths(language_categories) > 0) %>% unnest()
# Left table is master. Right table is the table of unnested column and own_id.
digital_fully_unnest <- digital_tb %>% left_join(table_inter1, by = "own_id") %>% left_join(table_inter2, by = "own_id") %>% left_join(table_inter3, by = "own_id") %>% left_join(table_inter4, by = "own_id")
View(digital_fully_unnest)
# Remove the list columns (.x suffix) from the original left table and put freshly joined columns (.y suffix) at front.
df <- digital_fully_unnest %>% select(-ends_with('.x'), -own_id) %>% select(ends_with('.y'), everything())
colnames(df) = gsub(".y", "", colnames(df))
View(df)
# For example, summarize using only interests. Get the unique data for the interest group first.
# .keep_all = TRUE retains all other columns associated to the unique ad.
int_summary_interests <- df %>% select() group_by(interests_categories) %>% distinct(ad_id, .keep_all = TRUE)
# For example, summarize using only interests. Get the unique data for the interest group first.
# .keep_all = TRUE retains all other columns associated to the unique ad.
int_summary_interests <- df %>% select() %>% group_by(interests_categories) %>% distinct(ad_id, .keep_all = TRUE)
# For example, summarize using only interests. Get the unique data for the interest group first.
# .keep_all = TRUE retains all other columns associated to the unique ad.
int_summary_interests <- df %>% select() group_by(interests_categories) %>% distinct(ad_id, .keep_all = TRUE)
# For example, summarize using only interests. Get the unique data for the interest group first.
# .keep_all = TRUE retains all other columns associated to the unique ad.
int_summary_interests <- df %>% select() tidyr::group_by(interests_categories) %>% distinct(ad_id, .keep_all = TRUE)
# For example, summarize using only interests. Get the unique data for the interest group first.
# .keep_all = TRUE retains all other columns associated to the unique ad.
int_summary_interests <- df %>% group_by(interests_categories) %>% distinct(ad_id, .keep_all = TRUE)
# Check to see if this mindset works
int_summary_interests %>% filter(ad_id == 1147)
View(int_summary_interests)
# It shows only 2 rows associated to ad_id 1147 becasue 1147 has only 2 interest categories, instead of 8 rows in the comprehensive df. This is the result we want. Now we can do a summarization such as total amount spent in each interest category
summary_interests <- int_summary_interests %>% summarize(total_spend_usd = sum(ad_spend_usd, na.rm = TRUE))
View(summary_interests)
# Another example, summarize using 2 categories, location and interests.
# Doing it in 1 line
summary_locations_interests <- df %>% group_by(location_categories, interests_categories) %>% distinct(ad_id, .keep_all = TRUE) %>% summarize(average_efficien_impressions = mean(efficien_impressions, na.rm = TRUE))
#first attempt at some aggregation
library(ggplot2)
#digital_dropna<-digital_tb_unnest %>% drop_na(ad_spend_usd) %>% drop_na(ad_impressions)
#to look at spending vs conversion rate
spend_conver<-df %>% select() %>% group_by(interests_categories) %>% distict(ad_id, .keep_all = TRUE)
#digital_dropna<-digital_tb_unnest %>% drop_na(ad_spend_usd) %>% drop_na(ad_impressions)
#to look at spending vs conversion rate
spend_conver<-df %>% group_by(interests_categories) %>% distict(ad_id, .keep_all = TRUE)
#digital_dropna<-digital_tb_unnest %>% drop_na(ad_spend_usd) %>% drop_na(ad_impressions)
#to look at spending vs conversion rate
spend_conver<- df %>% group_by(ad_id)
View(spend_conver)
#digital_dropna<-digital_tb_unnest %>% drop_na(ad_spend_usd) %>% drop_na(ad_impressions)
#to look at spending vs conversion rate
spend_conver<- df %>% distinct(ad_id, .keep_all = TRUE)
View(spend_conver)
g<-ggplot(spend_conver, aes(x=ad_spend_usd, y=conversion_rate))
g+geom_point()
g<-ggplot(spend_conver, aes(x=age_lower, y=conversion_rate))
g+geom_point()
View(summary_locations_interests)
View(summary_interests)
g<-ggplot(summary_interests, aes(x=interests_categories))
g+geom_point()
g<-ggplot(summary_interests, aes(x=interests_categories, y=total_spend_usd))
g+geom_point()
#to look at conversion rate by interest category
conver_rate_by_cat<- df %>% group_by(interests_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>%arrange()
View(conver_rate_by_cat)
#to look at conversion rate by interest category
conver_rate_by_cat<- df %>% group_by(interests_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% filter(max(conversion_rate))
#to look at conversion rate by interest category
conver_rate_by_cat<- df %>% group_by(interests_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>%
g<-ggplot(summary_interests, aes(x=interests_categories, y=total_spend_usd))
#to look at conversion rate by interest category
conver_rate_by_cat<- df %>% group_by(interests_categories_regex) %>% distinct(ad_id, .keep_all = TRUE)
View(conver_rate_by_cat)
g3<-ggplot(summary_location_interests, aes(x=location_categories, y=average_efficien_impressions))
g3<-ggplot(summary_locations_interests, aes(x=location_categories, y=average_efficien_impressions))
g3+geom_boxplot()
g3+geom_boxplot()
g2<-ggplot(summary_locations_interests,aes(x=location_categories))
g2+geom_bar()
```{r, warning= FALSE}
```{r, warning = FALSE}
```{r}
g3+geom_boxplot()
g<-ggplot(summary_interests, aes(x=interests_categories, y=average_efficien_impressions))
g+geom_point()
g<-ggplot(summary_location_interests, aes(x=interests_categories, y=average_efficien_impressions))
g+geom_point()
g<-ggplot(summary_location_interests, aes(x=interests_categories, y=average_efficien_impressions))
g<-ggplot(summary_locations_interests, aes(x=interests_categories, y=average_efficien_impressions))
g+geom_point()
g+geom_point(fill=location_categories)
g+geom_point(aes(col=location_categories)
g<-ggplot(summary_locations_interests, aes(x=interests_categories, y=average_efficien_impressions))
g + geom_point(aes(col=location_categories))
knitr::opts_chunk$set(echo = TRUE)
library(jsonlite)
library(dplyr)
library(tidyr)
digital <- fromJSON("https://www4.stat.ncsu.edu/~post/558/datasets/russian_ads.json", flatten = TRUE)
str(digital)
# As you look closer you would notice the first 4 columns (variables) are ‘list’ data type and they are ‘nested’. This is because each ‘categories’ columns include an JS array data object in the original JSON data.
# For Example (Look at the middle bracket[])
# "language_categories": [
#       "Not Specified"
#     ],
#     "placement_categories": [
#       "Facebook"
#     ],
#     "interests_categories": [],
#     "location_categories": [
#       "Midwest",
#       "Atlantic"
#     ]
# So even after the flattening the data, this type of variables are registered as ‘list’ data type and it has a list of the values (or atomic vector) for each row of the data frame. You can easily show the values inside of this type of variable by using as.character() function like below.
# Convert to tibble
digital_tb <- as_data_frame(digital)
# As an example
digital_tb %>% dplyr::mutate(location_categories = as.character(location_categories)) %>% dplyr::select(location_categories)
# To break out ‘categories’ list columns and create one row for each value, we can use ‘unnest()’ function from tidyr package.
# unnest 4 columns using stepwise approach. .drop = FALSE keeps other list columns that have not been unnested yet in the process.
digital_tb_unnest_noempty <- digital_tb %>% unnest(language_categories, .drop = FALSE) %>% unnest(placement_categories, .drop = FALSE) %>% unnest(interests_categories, .drop = FALSE) %>% unnest(location_categories, .drop = FALSE)
# Unnested columns are at the end of the dataset
dim(digital_tb_unnest_noempty)
# Checking dimension, there are 1803 observations, which is less than 3517 from the original parsed dataset. This is due to 3rd and 4th columns containing character(0), i.e. character array with 0 length, these 2 columns can't be unnested by default unnest(). Otherwise, it will drop all the rows with 1 or more empty data points in those list columns.
# We can use the _regex version of interests_categories and locations_categories, then use detect string functions for aggregation
# Or try to unnest the rows without empty points and join back to the master dataset. This seems to be a more holistic solution.
# Check if ad_id is unique
sum(table(digital_tb$ad_id)!=1)
# returns 0. ad_id can theoretically serve as a join key
# Wait!
sum(is.na(digital_tb$ad_id))
# unfortunately, there are 151 NAs in ad_id. Let's create our own row_id.
digital_tb <- digital_tb %>% mutate(own_id = rownames(digital_tb)) %>% select(own_id, everything())
# Grab language_categories list column and own_id, unnest it, assign it to table_inter1.
# unnest() by default will remove empty points character(0), but explicitly filtering first would result in faster execution. It probably does not matter in this case.
# Also, be aware that lengths() is different from length(). lengths() checks the length of each element of the list column
table_inter1 <- digital_tb %>% select(language_categories, own_id) %>% filter(lengths(language_categories) > 0) %>% unnest()
# If the unnest works properly, there should be a row for each value in the vectors.
# Check if the number of rows of table_inter1 is equal to the sum of array elements.
sum(lengths(digital_tb$language_categories)) == dim(table_inter1)[1]
# TRUE. We are good. Apply the same method to the other 3 columns.
table_inter2 <- digital_tb %>% select(placement_categories, own_id) %>% filter(lengths(placement_categories) > 0) %>% unnest()
table_inter3 <- digital_tb %>% select(interests_categories, own_id) %>% filter(lengths(interests_categories) > 0) %>% unnest()
table_inter4 <- digital_tb %>% select(location_categories, own_id) %>% filter(lengths(location_categories) > 0) %>% unnest()
# Left table is master. Right table is the table of unnested column and own_id.
digital_fully_unnest <- digital_tb %>% left_join(table_inter1, by = "own_id") %>% left_join(table_inter2, by = "own_id") %>% left_join(table_inter3, by = "own_id") %>% left_join(table_inter4, by = "own_id")
# It works. The resulting tibble is fully unnested. Rows are duplicated properly for each unique combination of category values.
# Remove the list columns (.x suffix) from the original left table and put freshly joined columns (.y suffix) at front.
df <- digital_fully_unnest %>% select(-ends_with('.x'), -own_id) %>% select(ends_with('.y'), everything())
colnames(df) = gsub(".y", "", colnames(df))
# Use df for further analysis
summary_convsions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate)
summary_convsions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate)
summary_convsions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate)
summary_conversions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate)
max_conversions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate)
max_conversions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate)
max_conversions<- df %>% group_by(location_categories_regex) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate))
View(max_conversions)
max_conversions<- df %>% group_by(location_categories) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = max(conversion_rate))
View(max_conversions)
max_conversions<- df %>% group_by(location_categories) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = mean(conversion_rate, na.rm = TRUE))
View(max_conversions)
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = mean(conversion_rate, na.rm = TRUE))
View(mean_conversions_placement)
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(max_conversion_rate = mean(conversion_rate, na.rm = TRUE)) %<% arrange()
View(mean_conversions_placement)
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE)) %<% arrange(mean_conversions_placement)
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE)) %>% arrange(mean_conversions_placement)
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE))
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE)) %>% arrange(df, mean_conversion_rate)
mean_conversions_placement<- df %>% group_by(placements) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE)) %>% arrange(mean_conversion_rate)
View(mean_conversions_placement)
library(ggplot2)
mean_conversions_region<- df %>% group_by(location_categories) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE))
View(mean_conversions_region)
g4<-ggplot(mean_conversions_region, aes(x=location_categories, y=mean_conversion_rate))
g4 + geom_point()
#mean conversion by region
mean_conversions_region<- df %>% group_by(location_categories) %>% distinct(ad_id, .keep_all = TRUE) %>% summarise(mean_conversion_rate = mean(conversion_rate, na.rm = TRUE))
g4<-ggplot(mean_conversions_region, aes(x=location_categories, y=mean_conversion_rate))
g4 + geom_point()
g4<-ggplot(mean_conversions_region, aes(x=location_categories, y=mean_conversion_rate))
g4 + geom_point()
View(mean_conversions_placement)
#this may be more appropriate for a table
knitr::kable(mean_conversions_placement)
